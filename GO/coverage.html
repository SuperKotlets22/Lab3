
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>structures: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">lab3-go/structures/array.go (96.7%)</option>
				
				<option value="file1">lab3-go/structures/hashtables.go (92.6%)</option>
				
				<option value="file2">lab3-go/structures/list.go (89.2%)</option>
				
				<option value="file3">lab3-go/structures/queue.go (91.4%)</option>
				
				<option value="file4">lab3-go/structures/stack.go (87.5%)</option>
				
				<option value="file5">lab3-go/structures/tree.go (93.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

type DynamicArray struct {
        Data []string
}

func NewDynamicArray() *DynamicArray <span class="cov8" title="1">{
        return &amp;DynamicArray{Data: make([]string, 0, 10)}
}</span>

func (da *DynamicArray) Size() int <span class="cov8" title="1">{
        return len(da.Data)
}</span>

func (da *DynamicArray) PushBack(val string) <span class="cov8" title="1">{
        da.Data = append(da.Data, val)
}</span>

func (da *DynamicArray) PushFront(val string) <span class="cov8" title="1">{
        da.Data = append([]string{val}, da.Data...)
}</span>

func (da *DynamicArray) InsertAt(index int, val string) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; len(da.Data) </span><span class="cov8" title="1">{
                panic("Index out of range")</span>
        }
        <span class="cov8" title="1">if index == len(da.Data) </span><span class="cov8" title="1">{
                da.PushBack(val)
                return
        }</span>
        <span class="cov8" title="1">da.Data = append(da.Data[:index+1], da.Data[index:]...)
        da.Data[index] = val</span>
}

func (da *DynamicArray) PopBack() <span class="cov8" title="1">{
        if len(da.Data) &gt; 0 </span><span class="cov8" title="1">{
                da.Data = da.Data[:len(da.Data)-1]
        }</span>
}

func (da *DynamicArray) PopFront() <span class="cov8" title="1">{
        if len(da.Data) &gt; 0 </span><span class="cov8" title="1">{
                da.Data = da.Data[1:]
        }</span>
}

func (da *DynamicArray) RemoveAt(index int) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(da.Data) </span><span class="cov8" title="1">{
                panic("Index out of range")</span>
        }
        <span class="cov8" title="1">da.Data = append(da.Data[:index], da.Data[index+1:]...)</span>
}

func (da *DynamicArray) Get(index int) string <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(da.Data) </span><span class="cov8" title="1">{
                panic("Index out of range")</span>
        }
        <span class="cov8" title="1">return da.Data[index]</span>
}

func (da *DynamicArray) Set(index int, val string) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(da.Data) </span><span class="cov8" title="1">{
                panic("Index out of range")</span>
        }
        <span class="cov8" title="1">da.Data[index] = val</span>
}

func (da *DynamicArray) Find(val string) int <span class="cov8" title="1">{
        for i, v := range da.Data </span><span class="cov8" title="1">{
                if v == val </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Сериализация (Текст)
func (da *DynamicArray) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fmt.Fprintln(file, len(da.Data))
        for _, v := range da.Data </span><span class="cov8" title="1">{
                fmt.Fprintln(file, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (da *DynamicArray) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var size int
        fmt.Fscanln(file, &amp;size)
        da.Data = make([]string, 0, size)

        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                var val string
                fmt.Fscanln(file, &amp;val)
                da.Data = append(da.Data, val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Сериализация (Бинарная - используем gob)
func (da *DynamicArray) SaveToBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        encoder := gob.NewEncoder(file)
        return encoder.Encode(da.Data)</span>
}

func (da *DynamicArray) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        decoder := gob.NewDecoder(file)
        return decoder.Decode(&amp;da.Data)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

type HashNode struct {
        Key   string
        Value string
        Next  *HashNode
}

type HashTable struct {
        Table    []*HashNode
        Capacity int
        Size     int
}

func NewHashTable(cap int) *HashTable <span class="cov8" title="1">{
        return &amp;HashTable{
                Table:    make([]*HashNode, cap),
                Capacity: cap,
                Size:     0,
        }
}</span>

func (ht *HashTable) hashFunction(key string) int <span class="cov8" title="1">{
        hash := 0
        for _, c := range key </span><span class="cov8" title="1">{
                hash = (hash*31 + int(c)) % ht.Capacity
        }</span>
        <span class="cov8" title="1">return hash</span>
}

func (ht *HashTable) Put(key, value string) <span class="cov8" title="1">{
        idx := ht.hashFunction(key)
        curr := ht.Table[idx]
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{
                        curr.Value = value
                        return
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov8" title="1">newNode := &amp;HashNode{Key: key, Value: value, Next: ht.Table[idx]}
        ht.Table[idx] = newNode
        ht.Size++</span>
}

func (ht *HashTable) Get(key string) string <span class="cov8" title="1">{
        idx := ht.hashFunction(key)
        curr := ht.Table[idx]
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{
                        return curr.Value
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (ht *HashTable) Remove(key string) <span class="cov8" title="1">{
        idx := ht.hashFunction(key)
        curr := ht.Table[idx]
        var prev *HashNode = nil

        for curr != nil </span><span class="cov8" title="1">{
                if curr.Key == key </span><span class="cov8" title="1">{
                        if prev == nil </span><span class="cov0" title="0">{
                                ht.Table[idx] = curr.Next
                        }</span> else<span class="cov8" title="1"> {
                                prev.Next = curr.Next
                        }</span>
                        <span class="cov8" title="1">ht.Size--
                        return</span>
                }
                <span class="cov8" title="1">prev = curr
                curr = curr.Next</span>
        }
}

// Сериализация (Пары Ключ-Значение)
func (ht *HashTable) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        fmt.Fprintln(file, ht.Size)
        for _, head := range ht.Table </span><span class="cov8" title="1">{
                curr := head
                for curr != nil </span><span class="cov8" title="1">{
                        fmt.Fprintln(file, curr.Key, curr.Value)
                        curr = curr.Next
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ht *HashTable) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var size int
        fmt.Fscanln(file, &amp;size)
        // Clear
        ht.Table = make([]*HashNode, ht.Capacity)
        ht.Size = 0
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                var k, v string
                fmt.Fscanln(file, &amp;k, &amp;v)
                ht.Put(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Для бинарной сериализации используем map для удобства gob
func (ht *HashTable) SaveToBinary(filename string) error <span class="cov8" title="1">{
        data := make(map[string]string)
        for _, head := range ht.Table </span><span class="cov8" title="1">{
                curr := head
                for curr != nil </span><span class="cov8" title="1">{
                        data[curr.Key] = curr.Value
                        curr = curr.Next
                }</span>
        }
        <span class="cov8" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewEncoder(file).Encode(data)</span>
}

func (ht *HashTable) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var data map[string]string
        if err := gob.NewDecoder(file).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ht.Table = make([]*HashNode, ht.Capacity)
        ht.Size = 0
        for k, v := range data </span><span class="cov8" title="1">{
                ht.Put(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

// --- SINGLY LINKED LIST ---

type SNode struct {
        Data string
        Next *SNode
}

type SinglyList struct {
        Head *SNode
        Tail *SNode
        Size int
}

func (l *SinglyList) PushBack(val string) <span class="cov8" title="1">{
        newNode := &amp;SNode{Data: val}
        if l.Head == nil </span><span class="cov8" title="1">{
                l.Head = newNode
                l.Tail = newNode
        }</span> else<span class="cov8" title="1"> {
                l.Tail.Next = newNode
                l.Tail = newNode
        }</span>
        <span class="cov8" title="1">l.Size++</span>
}

func (l *SinglyList) PushFront(val string) <span class="cov8" title="1">{
        newNode := &amp;SNode{Data: val, Next: l.Head}
        l.Head = newNode
        if l.Tail == nil </span><span class="cov8" title="1">{
                l.Tail = newNode
        }</span>
        <span class="cov8" title="1">l.Size++</span>
}

func (l *SinglyList) InsertAfter(target, val string) <span class="cov8" title="1">{
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Data == target </span><span class="cov8" title="1">{
                        newNode := &amp;SNode{Data: val, Next: curr.Next}
                        curr.Next = newNode
                        if curr == l.Tail </span><span class="cov8" title="1">{
                                l.Tail = newNode
                        }</span>
                        <span class="cov8" title="1">l.Size++
                        return</span>
                }
                <span class="cov0" title="0">curr = curr.Next</span>
        }
}

func (l *SinglyList) InsertBefore(target, val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Data == target </span><span class="cov8" title="1">{
                l.PushFront(val)
                return
        }</span>
        <span class="cov8" title="1">curr := l.Head
        for curr.Next != nil </span><span class="cov8" title="1">{
                if curr.Next.Data == target </span><span class="cov8" title="1">{
                        newNode := &amp;SNode{Data: val, Next: curr.Next}
                        curr.Next = newNode
                        l.Size++
                        return
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
}

func (l *SinglyList) PopFront() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next
        if l.Head == nil </span><span class="cov8" title="1">{
                l.Tail = nil
        }</span>
        <span class="cov8" title="1">l.Size--</span>
}

func (l *SinglyList) PopBack() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if l.Head == l.Tail </span><span class="cov8" title="1">{
                l.Head = nil
                l.Tail = nil
        }</span> else<span class="cov0" title="0"> {
                curr := l.Head
                for curr.Next != l.Tail </span><span class="cov0" title="0">{
                        curr = curr.Next
                }</span>
                <span class="cov0" title="0">curr.Next = nil
                l.Tail = curr</span>
        }
        <span class="cov8" title="1">l.Size--</span>
}

func (l *SinglyList) RemoveByValue(val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Data == val </span><span class="cov8" title="1">{
                l.PopFront()
                return
        }</span>
        <span class="cov8" title="1">curr := l.Head
        for curr.Next != nil </span><span class="cov8" title="1">{
                if curr.Next.Data == val </span><span class="cov8" title="1">{
                        if curr.Next == l.Tail </span><span class="cov8" title="1">{
                                l.Tail = curr
                        }</span>
                        <span class="cov8" title="1">curr.Next = curr.Next.Next
                        l.Size--
                        return</span>
                }
                <span class="cov8" title="1">curr = curr.Next</span>
        }
}

func (l *SinglyList) Search(val string) bool <span class="cov8" title="1">{
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Data == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Сериализация для SinglyList
func (l *SinglyList) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                fmt.Fprintln(file, curr.Data)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (l *SinglyList) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        l.Head = nil
        l.Tail = nil
        l.Size = 0
        var val string
        for </span><span class="cov8" title="1">{
                _, err := fmt.Fscanln(file, &amp;val)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.PushBack(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (l *SinglyList) SaveToBinary(filename string) error <span class="cov8" title="1">{
        var data []string
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                data = append(data, curr.Data)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewEncoder(file).Encode(data)</span>
}

func (l *SinglyList) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var data []string
        if err := gob.NewDecoder(file).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">l.Head, l.Tail, l.Size = nil, nil, 0
        for _, v := range data </span><span class="cov8" title="1">{
                l.PushBack(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// --- DOUBLY LINKED LIST ---

type DNode struct {
        Data string
        Next *DNode
        Prev *DNode
}

type DoublyList struct {
        Head *DNode
        Tail *DNode
        Size int
}

func (l *DoublyList) PushBack(val string) <span class="cov8" title="1">{
        newNode := &amp;DNode{Data: val}
        if l.Tail == nil </span><span class="cov8" title="1">{
                l.Head = newNode
                l.Tail = newNode
        }</span> else<span class="cov8" title="1"> {
                l.Tail.Next = newNode
                newNode.Prev = l.Tail
                l.Tail = newNode
        }</span>
        <span class="cov8" title="1">l.Size++</span>
}

func (l *DoublyList) PushFront(val string) <span class="cov8" title="1">{
        newNode := &amp;DNode{Data: val}
        if l.Head == nil </span><span class="cov0" title="0">{
                l.Head = newNode
                l.Tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.Next = l.Head
                l.Head.Prev = newNode
                l.Head = newNode
        }</span>
        <span class="cov8" title="1">l.Size++</span>
}

func (l *DoublyList) PopFront() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next
        if l.Head != nil </span><span class="cov8" title="1">{
                l.Head.Prev = nil
        }</span> else<span class="cov0" title="0"> {
                l.Tail = nil
        }</span>
        <span class="cov8" title="1">l.Size--</span>
}

func (l *DoublyList) PopBack() <span class="cov8" title="1">{
        if l.Tail == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Tail = l.Tail.Prev
        if l.Tail != nil </span><span class="cov0" title="0">{
                l.Tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                l.Head = nil
        }</span>
        <span class="cov8" title="1">l.Size--</span>
}

func (l *DoublyList) Search(val string) bool <span class="cov8" title="1">{
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                if curr.Data == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">curr = curr.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Сериализация (аналогично SinglyList, используем промежуточный slice для бинарки)
func (l *DoublyList) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                fmt.Fprintln(file, curr.Data)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (l *DoublyList) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        l.Head, l.Tail, l.Size = nil, nil, 0
        var val string
        for </span><span class="cov8" title="1">{
                _, err := fmt.Fscanln(file, &amp;val)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.PushBack(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (l *DoublyList) SaveToBinary(filename string) error <span class="cov8" title="1">{
        var data []string
        curr := l.Head
        for curr != nil </span><span class="cov8" title="1">{
                data = append(data, curr.Data)
                curr = curr.Next
        }</span>
        <span class="cov8" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewEncoder(file).Encode(data)</span>
}

func (l *DoublyList) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var data []string
        if err := gob.NewDecoder(file).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">l.Head, l.Tail, l.Size = nil, nil, 0
        for _, v := range data </span><span class="cov8" title="1">{
                l.PushBack(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

type Queue struct {
        Data     []string
        Front    int
        Rear     int
        Count    int
        Capacity int
}

func NewQueue(cap int) *Queue <span class="cov8" title="1">{
        return &amp;Queue{
                Data:     make([]string, cap),
                Capacity: cap,
                Front:    0,
                Rear:     -1,
                Count:    0,
        }
}</span>

func (q *Queue) resize() <span class="cov8" title="1">{
        newCap := q.Capacity * 2
        newData := make([]string, newCap)
        for i := 0; i &lt; q.Count; i++ </span><span class="cov8" title="1">{
                newData[i] = q.Data[(q.Front+i)%q.Capacity]
        }</span>
        <span class="cov8" title="1">q.Data = newData
        q.Capacity = newCap
        q.Front = 0
        q.Rear = q.Count - 1</span>
}

func (q *Queue) Push(val string) <span class="cov8" title="1">{
        if q.Count == q.Capacity </span><span class="cov8" title="1">{
                q.resize()
        }</span>
        <span class="cov8" title="1">q.Rear = (q.Rear + 1) % q.Capacity
        q.Data[q.Rear] = val
        q.Count++</span>
}

func (q *Queue) Pop() string <span class="cov8" title="1">{
        if q.Count == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">val := q.Data[q.Front]
        q.Front = (q.Front + 1) % q.Capacity
        q.Count--
        return val</span>
}

func (q *Queue) Peek() string <span class="cov8" title="1">{
        if q.Count == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return q.Data[q.Front]</span>
}

// Сериализация (сохраняем логический порядок)
func (q *Queue) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        fmt.Fprintln(file, q.Count)
        for i := 0; i &lt; q.Count; i++ </span><span class="cov8" title="1">{
                fmt.Fprintln(file, q.Data[(q.Front+i)%q.Capacity])
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var size int
        fmt.Fscanln(file, &amp;size)
        // Reset
        q.Capacity = size * 2
        if q.Capacity == 0 </span><span class="cov0" title="0">{
                q.Capacity = 10
        }</span>
        <span class="cov8" title="1">q.Data = make([]string, q.Capacity)
        q.Front, q.Rear, q.Count = 0, -1, 0
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                var val string
                fmt.Fscanln(file, &amp;val)
                q.Push(val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) SaveToBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        // Собираем в слайс для простоты сохранения
        temp := make([]string, 0, q.Count)
        for i := 0; i &lt; q.Count; i++ </span><span class="cov8" title="1">{
                temp = append(temp, q.Data[(q.Front+i)%q.Capacity])
        }</span>
        <span class="cov8" title="1">return gob.NewEncoder(file).Encode(temp)</span>
}

func (q *Queue) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var temp []string
        if err := gob.NewDecoder(file).Decode(&amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">q.Capacity = len(temp) * 2
        if q.Capacity == 0 </span><span class="cov0" title="0">{
                q.Capacity = 10
        }</span>
        <span class="cov8" title="1">q.Data = make([]string, q.Capacity)
        q.Front, q.Rear, q.Count = 0, -1, 0
        for _, v := range temp </span><span class="cov8" title="1">{
                q.Push(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

type Stack struct {
        Data []string
}

func (s *Stack) Push(val string) <span class="cov8" title="1">{
        s.Data = append(s.Data, val)
}</span>

func (s *Stack) Pop() string <span class="cov8" title="1">{
        if len(s.Data) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">val := s.Data[len(s.Data)-1]
        s.Data = s.Data[:len(s.Data)-1]
        return val</span>
}

func (s *Stack) Peek() string <span class="cov8" title="1">{
        if len(s.Data) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return s.Data[len(s.Data)-1]</span>
}

func (s *Stack) Size() int <span class="cov0" title="0">{
        return len(s.Data)
}</span>

// Сериализация
func (s *Stack) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        fmt.Fprintln(file, len(s.Data))
        for _, v := range s.Data </span><span class="cov8" title="1">{
                fmt.Fprintln(file, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var size int
        fmt.Fscanln(file, &amp;size)
        s.Data = make([]string, 0, size)
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                var val string
                fmt.Fscanln(file, &amp;val)
                s.Data = append(s.Data, val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) SaveToBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewEncoder(file).Encode(s.Data)</span>
}

func (s *Stack) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewDecoder(file).Decode(&amp;s.Data)</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package structures

import (
        "encoding/gob"
        "fmt"
        "os"
)

type TreeNode struct {
        Data  int
        Left  *TreeNode
        Right *TreeNode
}

type CompleteBinaryTree struct {
        Root *TreeNode
        Size int
}

func (t *CompleteBinaryTree) Insert(val int) <span class="cov8" title="1">{
        newNode := &amp;TreeNode{Data: val}
        if t.Root == nil </span><span class="cov8" title="1">{
                t.Root = newNode
                t.Size++
                return
        }</span>
        // BFS
        <span class="cov8" title="1">queue := []*TreeNode{t.Root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                curr := queue[0]
                queue = queue[1:]

                if curr.Left == nil </span><span class="cov8" title="1">{
                        curr.Left = newNode
                        t.Size++
                        return
                }</span> else<span class="cov8" title="1"> {
                        queue = append(queue, curr.Left)
                }</span>

                <span class="cov8" title="1">if curr.Right == nil </span><span class="cov8" title="1">{
                        curr.Right = newNode
                        t.Size++
                        return
                }</span> else<span class="cov8" title="1"> {
                        queue = append(queue, curr.Right)
                }</span>
        }
}

func (t *CompleteBinaryTree) Find(val int) bool <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">queue := []*TreeNode{t.Root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                curr := queue[0]
                queue = queue[1:]
                if curr.Data == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if curr.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, curr.Left)
                }</span>
                <span class="cov8" title="1">if curr.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, curr.Right)
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (t *CompleteBinaryTree) IsComplete() bool <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">queue := []*TreeNode{t.Root}
        flag := false
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                curr := queue[0]
                queue = queue[1:]

                if curr.Left != nil </span><span class="cov8" title="1">{
                        if flag </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">queue = append(queue, curr.Left)</span>
                } else<span class="cov8" title="1"> {
                        flag = true
                }</span>

                <span class="cov8" title="1">if curr.Right != nil </span><span class="cov8" title="1">{
                        if flag </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">queue = append(queue, curr.Right)</span>
                } else<span class="cov8" title="1"> {
                        flag = true
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Сериализация (Level Order)
func (t *CompleteBinaryTree) SaveToText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if t.Root == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">queue := []*TreeNode{t.Root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                curr := queue[0]
                queue = queue[1:]
                fmt.Fprintln(file, curr.Data)
                if curr.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, curr.Left)
                }</span>
                <span class="cov8" title="1">if curr.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, curr.Right)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *CompleteBinaryTree) LoadFromText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        t.Root = nil
        t.Size = 0
        var val int
        for </span><span class="cov8" title="1">{
                _, err := fmt.Fscanln(file, &amp;val)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">t.Insert(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *CompleteBinaryTree) SaveToBinary(filename string) error <span class="cov8" title="1">{
        // Собираем слайс значений
        var vals []int
        if t.Root != nil </span><span class="cov8" title="1">{
                queue := []*TreeNode{t.Root}
                for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                        curr := queue[0]
                        queue = queue[1:]
                        vals = append(vals, curr.Data)
                        if curr.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, curr.Left)
                        }</span>
                        <span class="cov8" title="1">if curr.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, curr.Right)
                        }</span>
                }
        }
        <span class="cov8" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return gob.NewEncoder(file).Encode(vals)</span>
}

func (t *CompleteBinaryTree) LoadFromBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        var vals []int
        if err := gob.NewDecoder(file).Decode(&amp;vals); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">t.Root = nil
        t.Size = 0
        for _, v := range vals </span><span class="cov8" title="1">{
                t.Insert(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
